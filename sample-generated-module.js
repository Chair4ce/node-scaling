/**
 * Full-Stack Utility Library
 * Generated by Code Swarm
 * 2026-01-25T21:47:59.099Z
 */

// === hashPassword ===
/**
 * Hashes a password using a bcrypt-like algorithm (pure JS implementation).
 *
 * @param {string} password The password to hash.
 * @returns {Promise<string>} A promise that resolves with the hashed password.
 * @throws {Error} If the password is not a string or is empty.
 */
async function hashPassword(password: string): Promise<string> {
  if (typeof password !== 'string') {
    throw new Error("Password must be a string.");
  }

  if (password.length === 0) {
    throw new Error("Password cannot be empty.");
  }

  const saltRounds = 10; // Adjust for performance/security tradeoff
  const salt = generateSalt(saltRounds);
  const hash = await bcryptHash(password, salt);
  return hash;

  // --- Internal helper functions (not exported) ---

  /**
   * Generates a salt string.
   * @param {number} rounds The number of rounds for salt generation.
   * @returns {string} The generated salt.
   */
  function generateSalt(rounds: number): string {
    let salt = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789./';
    const charactersLength = characters.length;
    for (let i = 0; i < rounds; i++) {
      salt += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return `$2a$${String(rounds).padStart(2, '0')}$${salt}`;
  }

  /**
   * Hashes the password with the given salt.  Simplified bcrypt-like hashing.
   * Note:  This is NOT a cryptographically secure bcrypt implementation.
   * @param {string} password The password to hash.
   * @param {string} salt The salt to use.
   * @returns {Promise<string>} A promise that resolves with the hashed password.
   */
  async function bcryptHash(password: string, salt: string): Promise<string> {
    // Simulate bcrypt rounds with simple iterations and string manipulation.
    let hash = password;
    for (let i = 0; i < 64; i++) { // Number of rounds for hashing.  Can be adjusted.
      hash = btoa(hash + salt).substring(0, 60); // Base64 encode, truncate
    }
    return hash;
  }
}

// === generateJWT ===
/**
 * Generates a simple JWT token (base64 encoded).
 *
 * @param {object} payload The payload to be encoded in the JWT.  Must be a serializable object.
 * @param {string} secret The secret key used for signing (not used in this simplified version).
 * @param {number} expiresIn The expiration time in seconds.
 * @returns {string} The generated JWT token.  Returns null if payload is invalid.
 * @throws {Error} If JSON serialization fails.
 */
const generateJWT = (payload, secret, expiresIn) => {
  if (!payload || typeof payload !== 'object') {
    return null;
  }

  if (typeof secret !== 'string') {
    console.warn("Secret should be a string.  This simplified JWT does not use a secret, so this is ignored.");
  }

  if (typeof expiresIn !== 'number' || expiresIn <= 0) {
    console.warn("expiresIn should be a positive number.  This simplified JWT does not encode expiry, so this is ignored.");
  }


  try {
    const header = {
      alg: 'none', // Indicate no signature
      typ: 'JWT'
    };

    const encodedHeader = btoa(JSON.stringify(header));
    const encodedPayload = btoa(JSON.stringify(payload));

    return `${encodedHeader}.${encodedPayload}.`; // No signature

  } catch (error) {
    console.error("Error during JSON serialization or base64 encoding:", error);
    throw new Error("Failed to generate JWT: " + error.message);
  }
};

// === parseJWT ===
/**
 * Parses and decodes a JWT token (without verification).
 *
 * @param {string} token The JWT token to parse.
 * @returns {object | null} The decoded payload of the JWT, or null if parsing fails.
 */
const parseJWT = (token) => {
  if (!token) {
    return null;
  }

  try {
    const base64Url = token.split('.')[1];
    if (!base64Url) {
      return null; // Invalid JWT format
    }

    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split('')
        .map(function (c) {
          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        })
        .join('')
    );

    return JSON.parse(jsonPayload);
  } catch (error) {
    // Handle decoding errors (e.g., invalid base64, invalid JSON)
    return null;
  }
};

// === sanitizeHTML ===
/**
 * Sanitize an HTML string to prevent XSS attacks.
 *
 * @param {string} html The HTML string to sanitize.
 * @returns {string} The sanitized HTML string.
 */
function sanitizeHTML(html) {
  if (typeof html !== 'string') {
    return '';
  }

  const sanitized = html.replace(/</g, '&lt;').replace(/>/g, '&gt;');
  return sanitized;
}

// === rateLimiter ===
/**
 * Creates a rate limiter that allows a maximum number of requests within a specified time window.
 *
 * @param {number} maxRequests The maximum number of requests allowed within the time window.
 * @param {number} windowMs The time window in milliseconds.
 * @returns {() => boolean} A function that returns true if a request is allowed, and false otherwise.
 */
function rateLimiter(maxRequests: number, windowMs: number): () => boolean {
  if (maxRequests <= 0) {
    throw new Error("maxRequests must be a positive number");
  }

  if (windowMs <= 0) {
    throw new Error("windowMs must be a positive number");
  }

  let requestCount = 0;
  let windowStart = Date.now();

  return () => {
    const now = Date.now();

    if (now - windowStart > windowMs) {
      // Reset the window if it has expired
      windowStart = now;
      requestCount = 0;
    }

    if (requestCount < maxRequests) {
      requestCount++;
      return true; // Request allowed
    } else {
      return false; // Request blocked
    }
  };
}

// === retry ===
/**
 * Retries an async function with exponential backoff.
 *
 * @param {Function} fn The async function to retry.
 * @param {number} maxRetries The maximum number of retries.
 * @param {number} baseDelay The base delay in milliseconds.
 * @returns {Promise<any>} A promise that resolves with the result of the function or rejects if the maximum number of retries is reached.
 */
async function retry(fn, maxRetries, baseDelay) {
  if (typeof fn !== 'function') {
    throw new TypeError('fn must be a function');
  }

  if (typeof maxRetries !== 'number' || maxRetries <= 0) {
    throw new TypeError('maxRetries must be a positive number');
  }

  if (typeof baseDelay !== 'number' || baseDelay < 0) {
    throw new TypeError('baseDelay must be a non-negative number');
  }

  let attempt = 0;

  while (true) {
    try {
      return await fn();
    } catch (error) {
      attempt++;
      if (attempt > maxRetries) {
        throw error;
      }

      const delay = baseDelay * Math.pow(2, attempt - 1);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

module.exports = {
  hashPassword,
  generateJWT,
  parseJWT,
  sanitizeHTML,
  rateLimiter,
  retry
};
