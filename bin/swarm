#!/usr/bin/env node
/**
 * Swarm CLI - Unified interface for parallel task execution
 * 
 * Daemon commands:
 *   swarm daemon start [--port 9999] [--workers 6]
 *   swarm daemon stop
 *   swarm daemon status
 *   swarm daemon restart
 * 
 * Direct commands (use daemon if running, else direct):
 *   swarm parallel "prompt1" "prompt2" ...
 *   swarm research "subject1" "subject2" --topic "angle"
 *   swarm bench [--tasks N]
 * 
 * Quick aliases:
 *   swarm start   â†’ swarm daemon start
 *   swarm stop    â†’ swarm daemon stop
 *   swarm status  â†’ swarm daemon status
 */

const path = require('path');
const fs = require('fs');
const http = require('http');
const os = require('os');
const { spawn } = require('child_process');

const SWARM_DIR = path.join(os.homedir(), 'clawd/skills/node-scaling');
const PID_FILE = path.join(os.tmpdir(), 'swarm-daemon.pid');
const LOG_FILE = path.join(os.tmpdir(), 'swarm-daemon.log');
const DEFAULT_PORT = 9999;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Helpers
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getPid() {
  try {
    return parseInt(fs.readFileSync(PID_FILE, 'utf8').trim(), 10);
  } catch {
    return null;
  }
}

function savePid(pid) {
  fs.writeFileSync(PID_FILE, String(pid));
}

function clearPid() {
  try { fs.unlinkSync(PID_FILE); } catch {}
}

function isRunning(pid) {
  try {
    process.kill(pid, 0);
    return true;
  } catch {
    return false;
  }
}

async function httpGet(port, path) {
  return new Promise((resolve) => {
    const req = http.request({
      hostname: 'localhost',
      port,
      path,
      method: 'GET',
      timeout: 2000,
    }, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try { resolve(JSON.parse(data)); }
        catch { resolve(null); }
      });
    });
    req.on('error', () => resolve(null));
    req.on('timeout', () => { req.destroy(); resolve(null); });
    req.end();
  });
}

async function httpPost(port, urlPath, body) {
  return new Promise((resolve, reject) => {
    const data = JSON.stringify(body);
    const req = http.request({
      hostname: 'localhost',
      port,
      path: urlPath,
      method: 'POST',
      timeout: 120000,
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(data),
      },
    }, (res) => {
      let buffer = '';
      let finalResult = null;
      
      res.on('data', chunk => {
        buffer += chunk;
        // Parse complete NDJSON lines
        const lines = buffer.split('\n');
        buffer = lines.pop(); // Keep incomplete line in buffer
        
        for (const line of lines) {
          if (!line.trim()) continue;
          try {
            const event = JSON.parse(line);
            if (event.event === 'progress' || event.event === 'task') {
              process.stdout.write('.');
            } else if (event.event === 'complete') {
              finalResult = event;
            } else if (event.event === 'error') {
              reject(new Error(event.error));
            }
          } catch {}
        }
      });
      
      res.on('end', () => {
        // Check remaining buffer for final event
        if (buffer.trim()) {
          try {
            const event = JSON.parse(buffer);
            if (event.event === 'complete') finalResult = event;
            if (event.event === 'error') reject(new Error(event.error));
          } catch {}
        }
        resolve(finalResult);
      });
    });
    req.on('error', reject);
    req.on('timeout', () => { req.destroy(); reject(new Error('timeout')); });
    req.write(data);
    req.end();
  });
}

async function isDaemonRunning(port = DEFAULT_PORT) {
  const health = await httpGet(port, '/health');
  return health?.status === 'ok';
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Daemon Commands
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function daemonStart(port, workers, foreground = false) {
  if (await isDaemonRunning(port)) {
    const status = await httpGet(port, '/status');
    console.log(`âœ… Swarm Daemon already running on port ${port}`);
    console.log(`   Uptime: ${Math.round(status.uptime / 1000)}s`);
    console.log(`   Workers: ${status.workers?.totalNodes || 'unknown'}`);
    return;
  }

  const daemonScript = path.join(SWARM_DIR, 'bin/swarm-daemon.js');
  
  if (foreground) {
    // Run in foreground (for debugging)
    require(daemonScript);
    return;
  }

  // Spawn detached daemon
  console.log('ğŸ Starting Swarm Daemon...');
  
  const out = fs.openSync(LOG_FILE, 'a');
  const err = fs.openSync(LOG_FILE, 'a');
  
  const child = spawn('node', [daemonScript, 'start', '--port', port, '--workers', workers], {
    detached: true,
    stdio: ['ignore', out, err],
    cwd: SWARM_DIR,
  });
  
  child.unref();
  savePid(child.pid);
  
  // Wait for startup
  console.log('   Waiting for startup...');
  for (let i = 0; i < 10; i++) {
    await new Promise(r => setTimeout(r, 500));
    if (await isDaemonRunning(port)) {
      const status = await httpGet(port, '/status');
      console.log(`âœ… Daemon ready on port ${port}`);
      console.log(`   Workers: ${status.workers?.totalNodes || workers}`);
      console.log(`   PID: ${child.pid}`);
      console.log(`   Log: ${LOG_FILE}`);
      return;
    }
  }
  
  console.log('âš ï¸  Daemon may not have started. Check log:');
  console.log(`   tail -f ${LOG_FILE}`);
}

async function daemonStop(port) {
  const pid = getPid();
  
  if (pid && isRunning(pid)) {
    console.log(`ğŸ›‘ Stopping Swarm Daemon (PID ${pid})...`);
    process.kill(pid, 'SIGTERM');
    clearPid();
    
    // Wait for shutdown
    for (let i = 0; i < 10; i++) {
      await new Promise(r => setTimeout(r, 200));
      if (!isRunning(pid)) {
        console.log('âœ… Stopped');
        return;
      }
    }
    console.log('âš ï¸  Process may still be running');
    return;
  }
  
  // Check if running without PID file
  if (await isDaemonRunning(port)) {
    console.log(`âš ï¸  Daemon running on port ${port} but PID unknown`);
    console.log(`   Find and kill manually: lsof -i :${port}`);
    return;
  }
  
  console.log('â„¹ï¸  Daemon not running');
}

async function daemonStatus(port) {
  console.log('ğŸ Swarm Daemon Status');
  console.log('â”€'.repeat(45));
  
  const health = await httpGet(port, '/health');
  
  if (!health) {
    console.log('   Status:     âŒ Not running');
    console.log('');
    console.log('   Start with: swarm start');
    return;
  }
  
  const status = await httpGet(port, '/status');
  
  console.log('   Status:     âœ… Running');
  console.log(`   Port:       ${port}`);
  console.log(`   PID:        ${getPid() || 'unknown'}`);
  console.log(`   Uptime:     ${Math.round(status.uptime / 1000)}s`);
  console.log(`   Workers:    ${status.workers?.totalNodes || health.workers}`);
  console.log(`   Requests:   ${status.requests}`);
  console.log(`   Tasks:      ${status.totalTasks}`);
  if (status.avgResponseMs > 0) {
    console.log(`   Avg req:    ${status.avgResponseMs}ms`);
  }
  if (status.avgTaskMs > 0) {
    console.log(`   Avg task:   ${status.avgTaskMs}ms`);
  }
  console.log(`   Provider:   ${status.config?.provider || 'gemini'}`);
  if (status.config?.webSearch) {
    console.log(`   Web search: âœ… ${status.config.webSearchMode || 'enabled'}`);
  }
  
  // Cache summary
  if (status.cache && (status.cache.entries > 0 || status.cache.hits > 0)) {
    console.log('');
    console.log('   ğŸ“¦ Cache');
    console.log(`   Entries:    ${status.cache.entries}/${status.cache.maxEntries}`);
    console.log(`   Hit rate:   ${status.cache.hitRate}`);
    console.log(`   Hits/Miss:  ${status.cache.hits}/${status.cache.misses}`);
  }

  // Cost summary
  const s = status.cost?.session || status.cost;
  const d = status.cost?.daily;
  if (s && (s.inputTokens > 0 || d)) {
    if (s.inputTokens > 0) {
      console.log('');
      console.log('   ğŸ’° Cost (this session)');
      const tokens = s.inputTokens + s.outputTokens;
      console.log(`   Tokens:     ${tokens.toLocaleString()}`);
      console.log(`   Swarm cost: $${s.swarmCost}`);
      console.log(`   Opus equiv: $${s.opusEquivalent}`);
      console.log(`   Saved:      $${s.saved} (${s.savingsMultiplier} cheaper)`);
    }
    if (d && parseFloat(d.swarmCost) > parseFloat(s.swarmCost || 0)) {
      console.log('');
      console.log('   ğŸ“Š Cost (today total)');
      const dTokens = d.inputTokens + d.outputTokens;
      console.log(`   Tokens:     ${dTokens.toLocaleString()}`);
      console.log(`   Swarm cost: $${d.swarmCost}`);
      console.log(`   Opus equiv: $${d.opusEquivalent}`);
      console.log(`   Saved:      $${d.saved} (${d.savingsMultiplier} cheaper)`);
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Task Commands
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function runParallel(prompts, port, useContext = false, fullOutput = false) {
  let finalPrompts = prompts;
  
  const useDaemon = await isDaemonRunning(port);
  
  if (useDaemon) {
    console.log(`ğŸ Using daemon (port ${port})`);
    process.stdout.write('   Processing');
    
    try {
      const result = await httpPost(port, '/parallel', { prompts: finalPrompts });
      console.log(' done!\n');
      
      // fullOutput passed as parameter
      console.log('ğŸ“Š Results:');
      result.results.forEach((r, i) => {
        const text = r ? r.trim() : 'âŒ FAILED';
        console.log(`\n[${i + 1}] ${fullOutput ? text : text.substring(0, 200)}`);
      });
      console.log(`\nâ±ï¸  ${result.duration}ms | âœ… ${result.stats.successful}/${prompts.length}`);
    } catch (e) {
      console.log(` error: ${e.message}`);
    }
  } else {
    console.log('ğŸ Direct execution (no daemon)');
    const { parallel } = require(path.join(SWARM_DIR, 'lib'));
    const result = await parallel(prompts, { quiet: false });
    
    console.log('\nğŸ“Š Results:');
    result.results.forEach((r, i) => {
      console.log(`\n[${i + 1}] ${r ? r.trim().substring(0, 200) : 'âŒ FAILED'}`);
    });
    console.log(`\nâ±ï¸  ${result.stats.totalDuration}ms | âœ… ${result.stats.successful}/${prompts.length}`);
  }
}

async function runResearch(subjects, topic, port, useContext = false) {
  if (useContext) {
    console.log('ğŸ§  Loading BrainDB context...');
    const queryPrompts = subjects.map(s => `${s} ${topic}`);
    const ctx = await recallBrainDB(queryPrompts);
    if (ctx) {
      topic = `${ctx}\n\n${topic}`;
      console.log(`   âœ… BrainDB context loaded`);
    } else {
      console.log('   âš ï¸  BrainDB unavailable, proceeding without context');
    }
  }
  
  const useDaemon = await isDaemonRunning(port);
  
  console.log(`ğŸ” Researching ${subjects.length} subjects: ${subjects.join(', ')}`);
  console.log(`ğŸ“Œ Topic: ${topic.substring(0, 100)}${topic.length > 100 ? '...' : ''}\n`);
  
  if (useDaemon) {
    console.log(`ğŸ Using daemon (port ${port})`);
    process.stdout.write('   Processing');
    
    try {
      const result = await httpPost(port, '/research', { subjects, topic });
      console.log(' done!\n');
      
      console.log('ğŸ“Š Research Results:');
      result.analyses.forEach(a => {
        console.log(`\n=== ${a.subject} ===`);
        console.log(a.analysis || 'No data');
      });
      console.log(`\nâ±ï¸  ${result.duration}ms`);
    } catch (e) {
      console.log(` error: ${e.message}`);
    }
  } else {
    console.log('ğŸ Direct execution (no daemon)');
    const { research } = require(path.join(SWARM_DIR, 'lib'));
    const result = await research(subjects, topic);
    
    console.log('\nğŸ“Š Research Results:');
    result.results.forEach((r, i) => {
      console.log(`\n=== ${subjects[i]} ===`);
      console.log(r.synthesis || r.analysis || 'No data');
    });
  }
}

async function runBench(taskCount, port) {
  const prompts = Array(taskCount).fill(null).map((_, i) => 
    `What is ${i + 1} * ${i + 1}? Reply with just the number.`
  );
  
  console.log(`âš¡ Benchmark: ${taskCount} parallel tasks\n`);
  
  const start = Date.now();
  await runParallel(prompts, port);
  const total = Date.now() - start;
  
  console.log(`\nğŸ“ˆ Total time: ${total}ms`);
  console.log(`   Per task:   ${Math.round(total / taskCount)}ms`);
  console.log(`   Throughput: ${Math.round(taskCount / (total / 1000) * 10) / 10} tasks/sec`);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Main
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function main() {
  const args = process.argv.slice(2);
  let command = args[0] || 'help';
  
  // Parse global options
  const portIdx = args.indexOf('--port');
  const port = portIdx !== -1 ? parseInt(args[portIdx + 1], 10) : DEFAULT_PORT;
  
  const workersIdx = args.indexOf('--workers');
  const workers = workersIdx !== -1 ? parseInt(args[workersIdx + 1], 10) : 6;

  // Quick aliases
  if (command === 'start') command = 'daemon-start';
  if (command === 'stop') command = 'daemon-stop';
  if (command === 'status') command = 'daemon-status';
  if (command === 'restart') command = 'daemon-restart';

  switch (command) {
    case 'daemon':
    case 'd': {
      const subCmd = args[1] || 'status';
      switch (subCmd) {
        case 'start': await daemonStart(port, workers); break;
        case 'stop': await daemonStop(port); break;
        case 'status': await daemonStatus(port); break;
        case 'restart':
          await daemonStop(port);
          await new Promise(r => setTimeout(r, 1000));
          await daemonStart(port, workers);
          break;
        case 'foreground':
        case 'fg':
          await daemonStart(port, workers, true);
          break;
        default:
          console.log('Unknown daemon command:', subCmd);
      }
      break;
    }

    case 'daemon-start': await daemonStart(port, workers); break;
    case 'daemon-stop': await daemonStop(port); break;
    case 'daemon-status': await daemonStatus(port); break;
    case 'daemon-restart':
      await daemonStop(port);
      await new Promise(r => setTimeout(r, 1000));
      await daemonStart(port, workers);
      break;

    case 'parallel':
    case 'p': {
      const useCtx = args.includes('--context');
      const prompts = args.slice(1).filter(a => !a.startsWith('--'));
      if (prompts.length === 0) {
        console.error('Usage: swarm parallel "prompt1" "prompt2" ... [--context]');
        process.exit(1);
      }
      const fullFlag = args.includes('--full');
      await runParallel(prompts, port, useCtx, fullFlag);
      break;
    }

    case 'research':
    case 'r': {
      const useCtx = args.includes('--context');
      const topicIdx = args.indexOf('--topic');
      const topic = topicIdx > 0 ? args[topicIdx + 1] : 'latest news and developments';
      const subjects = args.slice(1).filter((a, i, arr) => 
        !a.startsWith('--') && arr[i-1] !== '--topic' && arr[i-1] !== '--port' && a !== '--context'
      );
      
      if (subjects.length === 0) {
        console.error('Usage: swarm research "subject1" "subject2" --topic "angle" [--context]');
        process.exit(1);
      }
      await runResearch(subjects, topic, port, useCtx);
      break;
    }

    case 'bench':
    case 'benchmark': {
      const tasksIdx = args.indexOf('--tasks');
      const taskCount = tasksIdx > 0 ? parseInt(args[tasksIdx + 1], 10) : 10;
      await runBench(taskCount, port);
      break;
    }

    case 'savings':
    case 'cost': {
      const { SwarmMetrics } = require('../lib/metrics');
      const m = new SwarmMetrics();
      const report = m.getMonthlySavings();
      if (report.error) {
        console.log(`\n  ${report.error}\n`);
      } else {
        console.log(`\nğŸ Swarm Savings Report â€” ${report.month}`);
        console.log('â”€'.repeat(45));
        console.log(`   Days active: ${report.daysActive}`);
        console.log(`   Tasks run:   ${report.totalTasks.toLocaleString()}`);
        console.log(`   Tokens used: ${report.totalTokens.toLocaleString()}`);
        console.log(`   Swarm cost:  ${report.swarmCost}`);
        console.log(`   Opus equiv:  ${report.opusEquivalent}`);
        console.log(`   ğŸ’° Saved:    ${report.saved} (${report.savingsMultiplier} cheaper)`);
        console.log('');
      }
      break;
    }

    case 'log':
    case 'logs': {
      const { execSync } = require('child_process');
      const lines = args[1] || '50';
      try {
        execSync(`tail -${lines} ${LOG_FILE}`, { stdio: 'inherit' });
      } catch {
        console.log('No log file found');
      }
      break;
    }

    case 'capabilities':
    case 'caps': {
      try {
        const caps = await httpGet(port, '/capabilities');
        console.log('\nğŸ Swarm Capabilities (v' + (caps.version || '?') + ')');
        console.log('â”€'.repeat(55));
        console.log(`   Provider: ${caps.provider} (${caps.model})`);
        console.log(`   Web search: ${caps.webSearch ? 'âœ… grounding' : 'âŒ disabled'}`);
        console.log(`   Max workers: ${caps.limits?.maxWorkers || '?'}`);
        console.log(`   Retries: ${caps.limits?.retries || 0}`);
        console.log('');
        console.log('Execution Modes:');
        for (const [name, mode] of Object.entries(caps.modes || {})) {
          console.log(`\n   ğŸ“Œ ${name.toUpperCase()}`);
          console.log(`      ${mode.description}`);
          console.log(`      Use when: ${mode.when}`);
          if (mode.stageModes) {
            console.log('      Stage types:');
            for (const [sm, desc] of Object.entries(mode.stageModes)) {
              console.log(`        â€¢ ${sm}: ${desc}`);
            }
          }
          if (mode.builtInPerspectives) {
            console.log(`      Perspectives: ${mode.builtInPerspectives.join(', ')}`);
          }
          if (mode.builtInTransforms) {
            console.log(`      Transforms: ${mode.builtInTransforms.join(', ')}`);
          }
        }
        if (caps.cost) {
          const sc = caps.cost?.session || caps.cost;
          console.log(`\n   ğŸ’° Session cost: $${sc.swarmCost} (saved $${sc.saved})`);
        }
        console.log('');
      } catch (e) {
        console.error('âŒ Could not fetch capabilities. Is daemon running?');
      }
      break;
    }

    case 'chain': {
      const chainArg = args[1];
      if (!chainArg) {
        console.error('Usage: swarm chain <json-file> | echo \'{"stages":[...]}\' | swarm chain --stdin');
        process.exit(1);
      }
      
      let chainDef;
      if (chainArg === '--stdin') {
        const chunks = [];
        for await (const chunk of process.stdin) chunks.push(chunk);
        chainDef = JSON.parse(Buffer.concat(chunks).toString());
      } else {
        const filePath = require('path').resolve(chainArg);
        chainDef = JSON.parse(require('fs').readFileSync(filePath, 'utf8'));
      }

      console.log(`\nğŸ Running chain: ${chainDef.name || 'unnamed'}`);
      console.log(`   Stages: ${chainDef.stages?.length || 0}`);
      for (const stage of chainDef.stages || []) {
        const persp = stage.perspectives ? stage.perspectives.join(', ') : (stage.perspective || 'default');
        console.log(`   â†’ ${stage.name || '?'} (${stage.mode || 'single'}) [${persp}]`);
      }
      console.log('');

      // Stream from daemon
      await new Promise((resolve, reject) => {
        const postData = JSON.stringify(chainDef);
        const req = http.request({
          hostname: 'localhost',
          port,
          path: '/chain',
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(postData) },
          timeout: 120000,
        }, (res) => {
          let buffer = '';
          res.on('data', (chunk) => {
            buffer += chunk.toString();
            const lines = buffer.split('\n');
            buffer = lines.pop();
            for (const line of lines) {
              if (!line.trim()) continue;
              try {
                const event = JSON.parse(line);
                switch (event.event) {
                  case 'start':
                    console.log(`âš¡ ${event.message}`);
                    break;
                  case 'phase_start':
                    console.log(`\nğŸ“ Stage: ${event.name} (${event.taskCount} tasks)`);
                    break;
                  case 'phase_complete':
                    console.log(`   âœ… ${event.name} â€” ${event.durationMs}ms`);
                    break;
                  case 'task':
                    process.stdout.write('.');
                    break;
                  case 'complete':
                    console.log('\n');
                    console.log(`âœ… Chain complete in ${event.duration}ms`);
                    console.log(`   Tasks: ${event.stats?.totalTasks} (${event.stats?.successful} ok, ${event.stats?.failed} failed)`);
                    console.log('\n' + 'â”€'.repeat(55));
                    console.log('FINAL OUTPUT:');
                    console.log('â”€'.repeat(55));
                    if (typeof event.output === 'string') {
                      console.log(event.output);
                    } else if (Array.isArray(event.output)) {
                      event.output.forEach((o, i) => {
                        console.log(`\n--- Result ${i + 1} ---`);
                        console.log(o);
                      });
                    } else {
                      console.log(JSON.stringify(event.output, null, 2));
                    }
                    console.log('\n' + 'â”€'.repeat(55));
                    console.log('Stage breakdown:');
                    for (const stage of event.stages || []) {
                      console.log(`   ${stage.success ? 'âœ…' : 'âŒ'} ${stage.stage} (${stage.mode}) â€” ${stage.durationMs}ms â€” ${stage.results?.length || 0} results`);
                    }
                    console.log('');
                    break;
                  case 'error':
                    console.error(`âŒ Error: ${event.error || JSON.stringify(event.errors)}`);
                    break;
                }
              } catch {}
            }
          });
          res.on('end', resolve);
          res.on('error', reject);
        });
        req.on('error', reject);
        req.write(postData);
        req.end();
      });
      break;
    }

    case 'help':
    case '--help':
    case '-h':
    default:
      console.log(`
ğŸ Swarm CLI - Parallel Task Execution (Gemini Flash) v1.3.0

Daemon:
  swarm start                  Start daemon (background)
  swarm stop                   Stop daemon
  swarm status                 Show daemon status
  swarm restart                Restart daemon
  swarm daemon fg              Run in foreground (debug)
  swarm logs [N]               Show last N lines of log
  swarm savings                Monthly cost savings report

Execution:
  swarm parallel "p1" "p2"     Run prompts in parallel
  swarm research "s1" "s2"     Research subjects
       --topic "angle"         Research angle
  swarm chain <file.json>      Run refinement pipeline
  swarm chain --stdin          Read chain from stdin
  swarm bench --tasks N        Benchmark N parallel tasks

Discovery:
  swarm capabilities           Show available modes & perspectives

Options:
  --port PORT                  Daemon port (default: 9999)
  --workers N                  Warm workers (default: 6)
  --context                    Inject BrainDB memories into prompts

Chain perspectives: extractor, filter, enricher, analyst,
  synthesizer, challenger, optimizer, strategist, researcher, critic

Examples:
  swarm start
  swarm parallel "What is AI?" "What is ML?" "What is DL?"
  swarm research OpenAI Anthropic Google --topic "AI models 2025"
  swarm chain analysis-pipeline.json
  swarm capabilities
`);
  }
}

main().catch(e => {
  console.error('Error:', e.message);
  process.exit(1);
});
